#!/usr/bin/env python3
"""
File Watcher - Bronze Tier

Monitors filesystem for new files and creates task files in Needs_Action folder.
Original Bronze Tier implementation.
"""

import hashlib
import logging
from pathlib import Path
from datetime import datetime
from watchers.base_watcher import BaseWatcher

# Configure logging
logger = logging.getLogger('file_watcher')


class FileWatcher(BaseWatcher):
    """
    Watches filesystem for new files.
    Extends BaseWatcher with filesystem-specific implementation.
    """
    
    def __init__(self, vault_path: str, watch_path: str, poll_interval: int = 60):
        """
        Initialize file watcher.
        
        Args:
            vault_path: Path to AI_Employee_Vault
            watch_path: Path to directory to watch for new files
            poll_interval: Seconds between scans (default: 60)
        """
        super().__init__(vault_path, poll_interval)
        
        self.watch_path = Path(watch_path)
        self.watch_path.mkdir(exist_ok=True)
        
        # Track processed files to avoid duplicates
        self.processed_files = set()
        
        logger.info(f'FileWatcher initialized - Watching: {self.watch_path}')
    
    def scan(self) -> list:
        """
        Scan watch directory for new files.
        
        Returns:
            List of new file paths
        """
        new_files = []
        
        try:
            for file_path in self.watch_path.iterdir():
                if file_path.is_file():
                    # Create unique hash for file
                    file_hash = hashlib.md5(str(file_path).encode()).hexdigest()
                    
                    # Check if already processed
                    if file_hash not in self.processed_files:
                        new_files.append(file_path)
                        self.processed_files.add(file_hash)
                        logger.info(f'New file detected: {file_path.name}')
        
        except Exception as e:
            logger.error(f'Error scanning directory: {e}')
        
        return new_files
    
    def create_task_file(self, file_path: Path) -> Path:
        """
        Create task file in Needs_Action folder for new file.
        
        Args:
            file_path: Path to new file
            
        Returns:
            Path to created task file
        """
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        task_filename = f'FILE_{file_path.stem}_{timestamp}.md'
        task_path = self.needs_action / task_filename
        
        # Get file metadata
        try:
            file_size = file_path.stat().st_size
            file_modified = datetime.fromtimestamp(file_path.stat().st_mtime).isoformat()
        except Exception:
            file_size = 0
            file_modified = 'Unknown'
        
        # Create task file content
        content = f"""---
source: file_watcher
type: file_drop
original_name: {file_path.name}
original_path: {file_path}
size: {file_size}
modified: {file_modified}
detected: {datetime.now().isoformat()}
status: pending
---

# File Drop: {file_path.name}

**Original Path**: {file_path}  
**Size**: {file_size} bytes  
**Modified**: {file_modified}  
**Detected**: {datetime.now().isoformat()}

## File Content

<!-- If text file, content can be pasted here -->

## Suggested Actions

- [ ] Review file content
- [ ] Process file as needed
- [ ] Move to appropriate folder
- [ ] Delete if not needed

## Notes

<!-- Add notes here -->

---
*Generated by FileWatcher - Bronze Tier*
"""
        
        # Write task file
        task_path.write_text(content)
        
        # Log operation
        self.log_operation('create_task_file', {
            'file': str(file_path),
            'task_file': str(task_path),
            'size': file_size
        })
        
        return task_path


if __name__ == '__main__':
    # Test file watcher
    import sys
    
    if len(sys.argv) < 2:
        print('Usage: python file_watcher.py <vault_path> [watch_path]')
        sys.exit(1)
    
    vault_path = sys.argv[1]
    watch_path = sys.argv[2] if len(sys.argv) > 2 else str(Path(vault_path) / 'Inbox')
    
    watcher = FileWatcher(vault_path, watch_path, poll_interval=10)
    
    print(f'FileWatcher starting - Watching: {watch_path}')
    print('Press Ctrl+C to stop')
    
    watcher.run()
